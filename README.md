# Quick_Sort

## УСЛОВИЯ
Требуется отсортировать (quick sort) данные по:
1. решено больше задач (P=100 ,больше чем P=10)
    1) меньший штраф (F=10 ,больше чем F=100)
        а) лексикографический порядок (login="a" ,больше чем login="z")
Сортировка НЕ может потреблять O(n) дополнительной памяти для промежуточных данных (модификация in-place).

### Формат ввода -
- 1 стр. - n, число участников, 1 <= n <= 100'000
- n стррок - в каждой строке, через пробел:

login - логин участника, строка, маленькие латинские буквы, длина <= 20

P - число решённых задач, целое, 0 <= P <= 10^9

F - штраф, целое, 0 <= F <= 10^9

### Формат вывода 
-  выведите по порядку их логины участников по одному в строке.

### Ограничения: 
0.5секунд	17Mb

#### Пример 1:
    Ввод:				Вывод:
    5
    alla 4 100			gena
    gena 6 1000			timofey
    gosha 2 90			alla
    rita 2 90			gosha
    timofey 4 80		rita


## Решение.
Ожидаемая авторами идея: произвести быструю сортировку массива без выделения доп памяти
Алгоритм быстрой сортировки in-place:
Разбивать будем не сам массив, а диапозон элементов массива
  1) Выбираем опорный (англ. pivot) элемент.
  
    Рандомно, из числа элементов массива в диапозоне [begin, end).
		Это позволит получать неудачные разбиения не слишком часто.
    
  2) Делим диапозон [begin, end) на два поддиапазона (функция partition):
  
    partition принимает диапазон [begin, prev(end)] и pivot элемнт.
    находим элемент midle для которого:
      слева - элементы строго меньше опорного,
      справа - элементы не меньшие опорного.
    Размер одного поддиапазона в худшем случае (pivot меньше/больше всех) не уменьшается,
      но поскольку используется рандомный выбор pivot есть небольшая надежда,
      что алгоритм не уйдет в бесконечную рекурсию, но доказать это я не смогу
    В лучшем и среднем случае диапозон [begin, end) делится пополам.
  3) Применяем быструю сортировку к двум поддиапазонам, левому и правому.

    Используется рекурсия. Базовых случаев два:
			пустой диапазон и диапозон из одного элемента.
		В этом случае производим возврат на верхний уровень рекурсии.
После завершения рекурсивных вызовов массив остается отсортированным.
- n - число участников
#### Вычислительная сложность алгоритма: 	O(n log(n))
#### Пространственная сложность алгоритма:	O(n)

Для осуществления сортировки создана структура Reting{login, solvedTasks, penalty}, для которой определены:
- оператор сравнения меньше (используется внутри partition)
- оператор ввода (для упрощения ввода данных об участнике)
- оператор вывода (для упрощения вывода отсортированных данных)
